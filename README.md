# 당신의 인생을 기적으로 바꾸는 기록 앱 미라클 메모리📝

본 프로젝트는 [이정환님의 리액트 한입 크기로 잘라먹는 리액트 강의](https://www.inflearn.com/course/%ED%95%9C%EC%9E%85-%EB%A6%AC%EC%95%A1%ED%8A%B8)를 기준으로 제작된 UI에 `아토믹 디자인 패턴, 스타일 컴포넌트, 리덕스 환경`를 더하여 리팩토링 한 개인프로젝트 입니다.

### **[배포 URL]**

- URL:

<br/>

# **💡 개요**

```
📝 미라클 메모리 앱은 "미라클 모닝"의 영감을 받아 제작된 어플리케이션 입니다

🖋️ 특별한 삶은 매일 끊임없는 기록을 통해 완성된다고 믿습니다.

⛅ "기적의 아침"을 도와주는 미라클 메모리 앱을 통해서 매일 특별한 아침을 기록하세요.
```

# \***\*⚙️ 개발 환경 및 일지\*\***

<div align="center">
  <img src="https://img.shields.io/badge/React-61DAFB?style=for-the-badge&logo=React&logoColor=white"> 
 <img src="https://img.shields.io/badge/Redux-764ABC?style=for-the-badge&logo=React&logoColor=white"> 
 <img src="https://img.shields.io/badge/styledcomponents-DB7093?style=for-the-badge&logo=styled-components&logoColor=white"> 
</div>

### **[기술]**

- FrontEnd: React, Redux, Styled-components, LocalStorage

### **[ 개발 일지 ]**

- [[ 미라클 메모리 ] State 끌어올리기](https://www.notion.so/19cf237843a0428a9b37fa0963a8ed17)
- [[ 미라클 메모리 ] useRef? 아니면 useState?](https://www.notion.so/3e1bce9718554175a5b718079b10c188)
- [[ 미라클 메모리 ] 프롭스 드릴링과 Delete](https://www.notion.so/b7ec8d6f13b2441781da9e4135378839)
- [[ 미라클 메모리 ] Updata](https://www.notion.so/7261794e0b9647558a8436f3ec1c0855)
- [[ 미라클 메모리 ] API 활용하여 데이터 불러오기](https://www.notion.so/fd46dd6bb58f40a6a2d06228ae172570)
- [[ 미라클 메모리 ] 메모이제이션이란?](https://www.notion.so/187e5867165c4c4093ce07a77041d1b5)
- [[ 미라클 메모리 ] HOC을 사용한 컴포넌트 최적화 #React.Memo #불변성 #HOC](https://www.notion.so/e5d9b6f65d5d4a7fb85a5c5d6de586e1)
- [[ 미라클 메모리 ] useCallback 활용하여 불필요한 렌더링 막기](https://www.notion.so/88524250c41d412e8e68db40d6b9b5c2)
- [[ 미라클 메모리 ] 리덕스를 사용하여 상태로직 분리하기](https://www.notion.so/c387a191c4be4e14b14e9bc0f3069427)
- [[ 미라클 메모리 ] UseContext를 사용하여 전역에서 데이터 공급하기](https://www.notion.so/c4edbca043774ed3a77948c815fb1af2)
- [[ 미라클 메모리 ] 본격적으로 Reducer 환경 구축하기](https://www.notion.so/79b3899726994a048d5ffa94a256f41b)
- [[ 미라클 메모리 ] new Date를 사용하여 날짜별 데이터 표시하기](https://www.notion.so/c26a0cbc94b14b428e98b1fb11642126)
- [[ 미라클 메모리 ] 객체 깊은 복사하여 sort 구현하기](https://www.notion.so/5b429055afff499eb2e8d1097707f8c1)
- [[ 미라클 메모리 ] 클로저 활용하여 Date값 관리하기](https://www.notion.so/3ac1e930dfc1481f94fdcdd9fc532267)
- [[ 미라클 메모리 ] isSelected를 활용하여 스타일링하기](https://www.notion.so/830d474e9c8949cbad84365bd8933678)
- [[ 미라클 메모리 ] Edit Page에 데이터 넘기기](https://www.notion.so/c5e16a827e954f2695849a67426b8fd2)
- [[ 미라클 메모리 ] 웹 저장소 LocalStorage 학습하기](https://www.notion.so/720c1e810c6246498a95a242fc668a0d)
- [[ 미라클 메모리 ] 컴포넌트 렌더링 최적화하기 - (Home) - ContolMenu](https://www.notion.so/9ce3571d896848aeaae0fc5a4b3715ea)
- [[ 미라클 메모리 ] 컴포넌트 렌더링 최적화하기 - (Home) - Diaryitem](https://www.notion.so/9c4550ce6e3c4d828906b03b215f393e)
- [[ 미라클 메모리 ] 컴포넌트 렌더링 최적화히기 - (Edit) - DiaryEditor](https://www.notion.so/f6a56406e3ad4873ae522bf411c037c6)
- [[ 리팩토링 ] Module, Oaginism, Template, Page 구조의 아토믹 디자인 패턴 적용하기](https://www.notion.so/cd5b0dfd97e34de4a01519492c4a05ba)
- [[ 리팩토링 ] 리덕스 이해하기 및 Ducks 패턴 익히기](https://www.notion.so/cab7f60194e04bb4940b50e0c6444be4)
- [[ 리팩토링 ] 컨테이너 컴포넌트, 프리젠테이셔널 컴포넌트 구분짓기](https://www.notion.so/ef2d32a346a941e2b6acb6d04ba83709)
- [[ 리팩토링 ] redux 환경 프로젝트에 적용하기 및 LocalStorage 적용하기](https://www.notion.so/db2f0edd7b564967b74e625525065d1a)
- [[ 리팩토링 ] 컴포넌트 최적화 하여 불필요한 리-렌더링 막기](https://www.notion.so/2a877569b1d44a269fa86872272a3bd5)
- [[ 리팩토링 ] lodash 라이브러리 사용하여 객체 깊은 복사하기](https://www.notion.so/70050ce9e636476e814cf61e1be30778)
- [[ 리팩토링 ] Automic Design System](https://www.notion.so/8e581e2ab44341fc924ebe73976a8b6d)
- [[ 리팩토링 ] Redux Ducks Patten](https://www.notion.so/dfc5be80e6334ab183966272eff47df2)

### **[ 개발 이슈 ]**

- [옵셔널 체이닝 연산자 사용하여 에러 해결하기](https://www.notion.so/TIL-0a5e882508bf4901ae83808ff49c3e6e)
- [LocalStorage에 데이터 저장 시 중복 키 문제 해결하기](https://www.notion.so/TIL-React-LocalStorage-30c80935c4c9472da77fab635edcadc7)

<br/>

# 💡 구현사항

## [기능]

- Automic Patten DX
- Redux ducks patten
- Closuer를 활용한 월 별 데이터 상태 변경
- 게시글 Carete/ Read/ Update/ Delete
- sort, filter 메서드를 활용한 데이터 날짜별 정렬 및 필터링

## [UI Interaction]

- 액자형, 앨범형 UI
- Splash Screen
- Active Button

<br/>

# 🧐 프로젝트 특징

# AutoMic Design 패턴이란 ?

> 아토믹 디자인 패턴이란 ?

“ 디자인 요소들을 나누어 파악하고 이 요소들이 조합되는 과정을 통해서 디자인을 구성하는 방식 ”

<div>
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpZeYW%2FbtqBWssRQAW%2Fp5uMc3XeSIUYPk6PThaeek%2Fimg.png"/>
<div>

[출처: 아토믹디자인(Atomic Design) 방법론, 간단하게 이해하고 응용하기](https://uxdev.org/entry/%EC%95%84%ED%86%A0%EB%AF%B9%EB%94%94%EC%9E%90%EC%9D%B8-Atomic-Design-%EC%9B%90%EC%9E%90%EB%8B%A8%EC%9C%84%EB%94%94%EC%9E%90%EC%9D%B8-%EB%B0%A9%EB%B2%95%EB%A1%A0-%EA%B0%84%EB%8B%A8%ED%95%98%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B3%A0-%EC%9D%91%EC%9A%A9%ED%95%98%EA%B8%B0)

- `ATOM` 최소 디자인 요소들을 Atoms(원자들)로 파악한다
- `MOLECULES` Atoms들이 조합되어 MOLECULES(분자들)을 형성한다
- `ORGANISMS` MOLECULES(분자들)이 조합되어 보다 큰 의미 단위인 ORGANISMS(유기체)를 구성한다
- `TEMPLATES` ORGANISMS(유기체)이 모여 구성하는 실질적 디자인 화면이다.
- `PAGES` TEMPLATES(템플릿)들이 상황과 컨텐츠에 맞게 적용되면서 PAGES(페이지)를 구성한다.

# 난 왜 Automic Design 패턴을 왜 적용하려 하는가?

난 체계적인것을 좋아하고 정리하는 것을 좋아한다. 개발을 하는데 있어서 체계화가 잡혀있다면 프로젝트를 진행하는데 있어서 프로젝트의 주도권을 갖는 느낌을 갖게한다. 잘 갖추어진 디자인 시스템을 갖고 있다면 유지보수를 하기 좀 더 편하며 다른 사람에게 내가 생각하고 있는 체계성을 설명하는데 아주 유리하다. 고로 잘 정리된 프로젝트는 협업에 유리하다는 관점이다.

> Automic Design 패턴 적용 실패 경험

지난번 EarthMarket 프로젝트를 진행하면서 AutomicDesign 패턴을 구성하려고 하였으나 리액트의 상태 흐름에 대하여 제대로 이해하지 못했고 상태 관리를 어떻게 하는줄도 잘 몰랐다. 리액트의 생명주기, 가상돔의 역할, 재조정과정 등등을 고려한 개발을 전혀 하지 못했다. 그런 상태에서 그저 아토믹 디자인 패턴이 좋아보여 적용을 하려하였으니 당연히 구조를 제대로 잡지 못했다.. 하지만 이번에 리액트 강의를 제대로 들으며 상태관리에 대한 이해도가 높아졌기에, 실패의 경험을 이제 성공의 경험으로 만들고자 한다.

# 어떤식으로 AutomicDesign System을 적용했는가?

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161015066-48e382c7-06a7-4c76-8fde-683af98da297.png" />
</div>

Component폴더 하위에 atom, molecule, organisms, template으로 구성했다

## 폴더구조 - Atom

> 최소 디자인 요소들로 구성

- `예제 코드`

  ```jsx
  import styled from "styled-components";

  const Button = ({ text, type, onClick }) => {
    const btnType = ["positive", "negative"].includes(type) ? type : "default";
    return (
      <StyledButton className={btnType} onClick={onClick}>
        {text}
      </StyledButton>
    );
  };

  Button.defaultProps = {
    type: "default",
  };

  const StyledButton = styled.button`
  ...
  `;

  export default Button;
  ```

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161015528-7f3b271a-d05c-4883-9da4-af5f19371d08.png" width="29%" />
<img src="https://user-images.githubusercontent.com/79143800/161015512-cf07d2e5-4393-4426-bcf6-05b8fdda1431.png" width="50%"/>
</div>

<aside>
💡 Button 역할 이외에 그 어떤 역할도 하고있지 않다. 이렇게 만들어진 Atom들은 molecule에 구성 요소로 역할을 하게 된다.
</aside>

## 폴더구조 - molecule

> Atoms들이 조합되어 MOLECULES(분자들)을 형성한다

- `예제 코드`

  ```jsx
  import React from "react";
  import styled from "styled-components";
  import { getStringDate } from "../../../util/date";
  import CommonText from "../../atom/text/CommonText";

  const HomeInfoBox = ({ onClick, date, content }) => {
    return (
      <Wrapper onClick={onClick}>
        <CommonText
          descript={getStringDate(date).dataString()}
          size={25}
          pb={10}
        />
        <CommonText descript={content} size={18} />
      </Wrapper>
    );
  };

  const Wrapper = styled.div`
  ...
  `;

  export default HomeInfoBox;
  ```

  <div align='center' >
  <img src="https://user-images.githubusercontent.com/79143800/161016456-136ab117-0242-46bd-9f6e-17a78232f4c5.png" width="29%" />
  <img src="https://user-images.githubusercontent.com/79143800/161016446-7a55cc93-43ad-4872-a161-17eda2c79ade.png" width="50%"/>
  </div>

<aside>
💡 분자들은 Atoms의 조합으로 생기게 된다. 날짜와 내용을 표시하는 Atom요소들을  HomeInfoBox라는 Molecule 컴포넌트로 관리해준다. 나는 molecule 역할을 하는 컴포넌트는 Box라는 컴포넌트 명으로 통일 시켰다.

</aside>

## 폴더구조 - Organism

> MOLECULES(분자들)이 조합되어 보다 큰 의미 단위인 ORGANISMS(유기체)를 구성한다

- `예제코드`

  ```jsx
  import React from "react";
  import { useNavigate } from "react-router-dom";
  import styled from "styled-components";
  import HomeEmotionBox from "../../molecule/home/HomeEmotionBox";
  import HomeInfoBox from "../../molecule/home/HomeInfoBox";
  import HomeButtonBox from "../../molecule/home/HomeButtonBox";

  const HomeMemoItem = ({ emotion, id, date, content }) => {
    const navigate = useNavigate();
    const goDetail = () => {
      navigate(`/detail/${id}`);
    };
    const goEdit = () => {
      navigate(`/edit/${id}`);
    };
    return (
      <MomoItem>
        <HomeEmotionBox onClick={goDetail} emotion={emotion} />
        <HomeInfoBox onClick={goDetail} date={date} content={content} />
        <HomeButtonBox text={"수정하기"} onClick={goEdit} />
      </MomoItem>
    );
  };

  const MomoItem = styled.li`
  ...
  `;

  export default HomeMemoItem;
  ```

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161016746-4e7fcbd9-b47b-44ea-9563-1d8f1046e9ff.png" width="29%" />
<img src="https://user-images.githubusercontent.com/79143800/161016737-58cb5d71-ca2f-4fa2-a021-78074b545c9e.png" width="50%"/>
</div>

<aside>
💡 유기체는 분자들이 모여 형성된 것이다. 나는 유기체 컴포넌트를 기본적으로 Item이라고 칭했으며, Item들의 성격에 따라서 list와 Container라는 컴포넌트로 나누어 주었다. 그 외에 공통으로 쓰이는 컴포넌트는 common 폴더에 담아주었다 그렇다면 container, item, list 컴포넌트들의 역할은 무엇일까?

</aside>

## Organism- Home 트리 구조를 보면서 구조 파악하기

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161017217-b35425a9-1577-40ca-bfa5-1f17993877b2.png" width="100%" />
</div>

### organism - container

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161017224-28100b8e-ff0b-45c1-a447-8d1f04a6b3a0.png" width="50%" />
</div>

```jsx
const HomeContainer = ({ MonthData }) => {
  const [sortType, setSortType] = useState("latest");
  const [filter, setFilter] = useState("all");
  return (
    <>
      <HomeSelectItem
        sortType={sortType}
        setSortType={setSortType}
        filter={filter}
        setFilter={setFilter}
      />
      <HomeMemoList filter={filter} sortType={sortType} MonthData={MonthData} />
    </>
  );
};
```

먼저 HomeContainer의 역할은 두 유기체가 동일한 `상태값을 공유한다`는 특징을 갖고 있다. 둘 모두 sortType과 filter라는 상태값을 공유하고 있으며 해당 상태값에 따라 렌더링 되는 결과물이 달라진다. 그렇기에 둘의 연관성을 고려해 Container라는 컴포넌트로 분류하여 함께 묶어주었다.

### organism - list

1. 여러 Organism의 요소들을 묶을 경우

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161017226-1454ed26-548e-42f7-a13b-8d5e20979e2b.png" width="50%" />
</div>

Homememoitem는 List 하나의 아이템 역할을 한다. 하지만 화면의 구성 요소로 보았을 때 Ul태그의 역할을 하는 컨테이너 역시 organism의 구성 요소로 볼 수 있다. 그렇기에 여러개의 Organism을 묶어 하나의 organism을 구성하는 경우에 List라는 폴더로 구분지었다.

2. 여러 Organism 안에 또 다른 Organism이 있는 경우

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161017228-ab899b1c-3c7d-4016-afdf-7c6b884ba04d.png" width="50%" />
</div>

빨간색 블록 영역이 Organism > `Organism`을 의미한다

```jsx
import React from "react";
import SubTitle from "../../atom/text/SubTitle";
import EditorEmotionList from "../list/EditorEmotionList";

const EditorEmotionItem = ({ emotion, onClick }) => {
  return (
    <section>
      <SubTitle text={"오늘의 점수"} />
      <EditorEmotionList emotion={emotion} onClick={onClick} />
    </section>
  );
};
export default React.memo(EditorEmotionItem);
```

`EditorEmotionItem` 컴포넌트는 Organism의 역할을 한다. 하지만 `EditorEmotionList` 컴포넌트 역시도 Organism의 역할을 하고 있다. EditorEmotionList 컴포넌트의 경우에는 Box의 List를 담아서 표현하기에 Organism이라고 할 수 있다. 그렇기에 이런 Item요소에 또 다른 Organism 요소가 중복으로 들어간 경우에는 List 폴더로 구분지었다.

### organism - item

Item은 요소를 나타내는 하나의 블럭을 의미한다. 때에 따라서 List에 속할 수도 있고 여러개의 Item이 컨테이너에 속할 수 있는 성질을 가졌다.

## 폴더구조 - Template

- `TEMPLATES` ORGANISMS(유기체)이 모여 구성하는 실질적 디자인 화면이다.

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161017231-62619b44-6323-4000-a8fe-26a2009f9961.png" width="40%" height="100px"/>
<img src="https://user-images.githubusercontent.com/79143800/161017234-148b6cd9-e17a-4de8-9d9c-8f2c0df8faa1.png" width="50%"/>
</div>

<br/>

# 마치며

구조를 잡다보니깐 계속해서 마음에 안드는 부분이 존재했고 상태관리와 컴포넌트의 레이아웃을 함께 고려하여 컴포넌트를 구조분해 하는일이 쉽지 않음을 느꼈다. 리액트의 특성상 컴포넌트의 상태가 변화면 리-렌더링이 일어나기 때문에 한 구조로 묶어버리더라도 결국에 컨테이너로 묶어버린 컴포넌트들이 리-렌더링 상태애 계속되서 노출이 된다면 이는 성능 최적화에 실패하는 경우가 되어버리기 때문이다.

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161017235-f240c62a-a433-422e-b86f-c26d928e9f55.png" />
</div>

EditorTemplate 같은 경우에는 상태를 입력함에 따라 상태값이 변화가 되는 경우가 많았다. 예를들면 위 Item요소들을 한 군데로 묶어버리고 Props로 상태 변경을 하는 상태변경 함수를 전달하여 레이아웃을 좀 더 명확하게 분리를 하는 방법도 있지만 그렇게 할 경우 Item 요소중 하나의 값만 변경이 되어버려도 컴포넌트 전체가 리-렌더링 되는 문제가 발생하게 된다.

결국에는 이런 디자인 시스템을 적용하기 위해서는 디자이너와 정말 많은 커뮤니케이션이 일어나야 할 것 같다는 생각이 들었다. 디자이너가 오로지 디자인의 관점으로만 레이아웃을 만들고 개발자가 UI를 만들어야 하는 상황이 온다면 개발자는 디자이너가 의도한대로 컴포넌트를 재 설계해야한다. 이 과정에서 최적화와 상태관리를 위하여 프로젝트 구조의 흐름을 깨뜨리는 상황이 발생할 수 있을 것 같다고 생각했다.

<br>

# 2. Redux Ducks Patten

> What is Redux Ducks Patten

기존에 EarthMarket 프로젝트를 진행하면서 Action Type(액션 타입), Action Creator(액션 생성 함수), Reducer(리듀서)를 모두 하나의 파일로 관리하지 않고 따로따로 역할을 분리해서 사용했다. 기존 어스마켓의 프로젝트 규모가 큰 편이었기에 파일별로 역할을 나누었었다. 하지만 Redux Ducks패턴은 기존에 리덕스 모듈들을 파일별로 나누어 작성하는 것이 아닌 하나의 파일에 두어서 함께 관리하는 것이다

```jsx
// Constant

const MEMORY_INIT = "MEMORY_INIT";
const MEMORY_CREATE = "MEMORY_CREATE";
const MEMORY_REMOVE = "MEMORY_REMOVE";
const MEMORY_UPDATE = "MEMORY_UPDATE";

// Action

export const initalData = (data) => ({
...
});

export const onCreate = (date, content, emotion) => ({
...
});

export const onRemove = (targetId) => ({
...
});

export const onEdit = (targetId, date, content, emotion) => ({
...
});

// Reducer

const memoryReducer = (state = {}, action) => {
  let newState = [];
  switch (action.type) {
    case MEMORY_INIT: {
...
    }
    case MEMORY_CREATE: {
...
    }
    case MEMORY_REMOVE: {
...
    }
    case MEMORY_UPDATE: {
...
    }
    default:
      return state;
  }
...
  return newState;
};

export default memoryReducer;
```

Ducks 패턴 같은 경우에는 module이라는 폴더에서 Ducks 패턴으로 만들어진 파일을 관리한다. 그리고 store 로직을 index.js를 통해서 관리를 해주는데 나는 방식을 좀 다르게했다. 데이터가 실질적으로 관리가 되는 reducer함수는 store함수에서 관리되는게 좀 더 구분짓기 편하다고 여겨 index.js가 아닌 store.js파일을 만들어서 관리해주었다.

- Store.js

```jsx
import { combineReducers } from "redux";
import { createStore } from "redux";
import memoryReducer from "./module/memoryReducer";
import { composeWithDevTools } from "redux-devtools-extension";

const reducer = combineReducers({
  memoryReducer,
});

const store = createStore(reducer, composeWithDevTools());

export default store;
```

<br>

# 📲 프로젝트 실행 방법

🖥 코드 실행

```
  npm install
  npm start
```

<br/>

# 📁 프로젝트 구조

<br/>

# 💡 라이브러리
