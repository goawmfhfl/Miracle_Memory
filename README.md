# 당신의 인생을 기적으로 바꾸는 기록 앱 미라클 메모리📝

본 프로젝트는 [이정환님의 리액트 한입 크기로 잘라먹는 리액트 강의](https://www.inflearn.com/course/%ED%95%9C%EC%9E%85-%EB%A6%AC%EC%95%A1%ED%8A%B8)를 기준으로 제작된 UI에 `아토믹 디자인 패턴, 스타일 컴포넌트, 리덕스 환경`를 더하여 리팩토링 한 개인프로젝트 입니다.

### **[배포 URL]**

- URL:

<br/>

# **💡 개요**

```
📝 미라클 메모리 앱은 "미라클 모닝"의 영감을 받아 제작된 어플리케이션 입니다

🖋️ 특별한 삶은 매일 끊임없는 기록을 통해 완성된다고 믿습니다.

⛅ "기적의 아침"을 도와주는 미라클 메모리 앱을 통해서 매일 특별한 아침을 기록하세요.
```

# \***\*⚙️ 개발 환경 및 일지\*\***

<div align="center">
  <img src="https://img.shields.io/badge/React-61DAFB?style=for-the-badge&logo=React&logoColor=white"> 
 <img src="https://img.shields.io/badge/Redux-764ABC?style=for-the-badge&logo=React&logoColor=white"> 
 <img src="https://img.shields.io/badge/styledcomponents-DB7093?style=for-the-badge&logo=styled-components&logoColor=white"> 
</div>

### **[기술]**

- FrontEnd: React, Redux, Styled-components, LocalStorage

### **[ 개발 일지 ]**


- [[ 미라클 메모리 ] State 끌어올리기](https://www.notion.so/19cf237843a0428a9b37fa0963a8ed17)
- [[ 미라클 메모리 ] useRef? 아니면 useState?](https://www.notion.so/3e1bce9718554175a5b718079b10c188)
- [[ 미라클 메모리 ] 프롭스 드릴링과 Delete](https://www.notion.so/b7ec8d6f13b2441781da9e4135378839)
- [[ 미라클 메모리 ] Updata](https://www.notion.so/7261794e0b9647558a8436f3ec1c0855)
- [[ 미라클 메모리 ] API 활용하여 데이터 불러오기](https://www.notion.so/fd46dd6bb58f40a6a2d06228ae172570)
- [[ 미라클 메모리 ] 메모이제이션이란?](https://www.notion.so/187e5867165c4c4093ce07a77041d1b5)
- [[ 미라클 메모리 ] HOC을 사용한 컴포넌트 최적화 #React.Memo #불변성 #HOC](https://www.notion.so/e5d9b6f65d5d4a7fb85a5c5d6de586e1)
- [[ 미라클 메모리 ] useCallback 활용하여 불필요한 렌더링 막기](https://www.notion.so/88524250c41d412e8e68db40d6b9b5c2)
- [[ 미라클 메모리 ] 리덕스를 사용하여 상태로직 분리하기](https://www.notion.so/c387a191c4be4e14b14e9bc0f3069427)
- [[ 미라클 메모리 ] UseContext를 사용하여 전역에서 데이터 공급하기](https://www.notion.so/c4edbca043774ed3a77948c815fb1af2)
- [[ 미라클 메모리 ] 본격적으로 Reducer 환경 구축하기](https://www.notion.so/79b3899726994a048d5ffa94a256f41b)
- [[ 미라클 메모리 ] new Date를 사용하여 날짜별 데이터 표시하기](https://www.notion.so/c26a0cbc94b14b428e98b1fb11642126)
- [[ 미라클 메모리 ] 객체 깊은 복사하여 sort 구현하기](https://www.notion.so/5b429055afff499eb2e8d1097707f8c1)
- [[ 미라클 메모리 ] 클로저 활용하여 Date값 관리하기](https://www.notion.so/3ac1e930dfc1481f94fdcdd9fc532267)
- [[ 미라클 메모리 ] isSelected를 활용하여 스타일링하기](https://www.notion.so/830d474e9c8949cbad84365bd8933678)
- [[ 미라클 메모리 ] Edit Page에 데이터 넘기기](https://www.notion.so/c5e16a827e954f2695849a67426b8fd2)
- [[ 미라클 메모리 ] 웹 저장소 LocalStorage 학습하기](https://www.notion.so/720c1e810c6246498a95a242fc668a0d)
- [[ 미라클 메모리 ] 컴포넌트 렌더링 최적화하기 - (Home) - ContolMenu](https://www.notion.so/9ce3571d896848aeaae0fc5a4b3715ea)
- [[ 미라클 메모리 ] 컴포넌트 렌더링 최적화하기 - (Home) - Diaryitem](https://www.notion.so/9c4550ce6e3c4d828906b03b215f393e)
- [[ 미라클 메모리 ] 컴포넌트 렌더링 최적화히기 - (Edit) - DiaryEditor](https://www.notion.so/f6a56406e3ad4873ae522bf411c037c6)
- [[ 리팩토링 ] Module, Oaginism, Template, Page 구조의 아토믹 디자인 패턴 적용하기](https://www.notion.so/cd5b0dfd97e34de4a01519492c4a05ba)
- [[ 리팩토링 ] 리덕스 이해하기 및 Ducks 패턴 익히기](https://www.notion.so/cab7f60194e04bb4940b50e0c6444be4)
- [[ 리팩토링 ] 컨테이너 컴포넌트, 프리젠테이셔널 컴포넌트 구분짓기](https://www.notion.so/ef2d32a346a941e2b6acb6d04ba83709)
- [[ 리팩토링 ] redux 환경 프로젝트에 적용하기 및 LocalStorage 적용하기](https://www.notion.so/db2f0edd7b564967b74e625525065d1a)
- [[ 리팩토링 ] 컴포넌트 최적화 하여 불필요한 리-렌더링 막기](https://www.notion.so/2a877569b1d44a269fa86872272a3bd5)
- [[ 리팩토링 ] lodash 라이브러리 사용하여 객체 깊은 복사하기](https://www.notion.so/70050ce9e636476e814cf61e1be30778)
- [[ 리팩토링 ] Automic Design System](https://www.notion.so/8e581e2ab44341fc924ebe73976a8b6d)
- [[ 리팩토링 ] Redux Ducks Patten](https://www.notion.so/dfc5be80e6334ab183966272eff47df2)

### **[ 개발 이슈 ]**

- [옵셔널 체이닝 연산자 사용하여 에러 해결하기](https://www.notion.so/TIL-0a5e882508bf4901ae83808ff49c3e6e)
- [LocalStorage에 데이터 저장 시 중복 키 문제 해결하기](https://www.notion.so/TIL-React-LocalStorage-30c80935c4c9472da77fab635edcadc7)

<br/>

# 💡 구현사항

## [기능]

- Automic Patten DX
- Redux ducks patten
- Closuer를 활용한 월 별 데이터 상태 변경
- 게시글 Carete/ Read/ Update/ Delete
- sort, filter 메서드를 활용한 데이터 날짜별 정렬 및 필터링

## [UI Interaction]

- 액자형, 앨범형 UI
- Splash Screen
- Active Button

<br/>








<div align='center'>

|                                                            0.Splash                                                            |                                                           1.홈화면                                                           |
| :----------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------: |
| <img src="https://user-images.githubusercontent.com/79143800/161473842-9a1edbc2-a72c-4523-afd4-bdf7a964ce73.gif" width="300"/> | <img src="https://user-images.githubusercontent.com/79143800/161474082-e3906759-7acc-4c4b-807c-d67402fb232e.gif" width="300"/> |

|                                                            2.홈화면 - 앨범,리스트                                                            |                                                            3.홈화면 - 옵션                                                            |
| :----------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------: |
| <img src="https://user-images.githubusercontent.com/79143800/161474311-c337cdd9-dade-48f4-a449-1329fe54acfd.gif" width="300"/> | <img src="https://user-images.githubusercontent.com/79143800/161474627-1c7e872e-3ec7-459f-a889-7202cbf9dbda.gif" width="300"/> |

|                                                          4.Create                                                           |                                                           5.Update                                                           |
| :----------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------: |
| <img src="https://user-images.githubusercontent.com/79143800/161475118-63ef320c-dde9-4694-b866-899d23b9d4c3.gif" width="300"/> | <img src="https://user-images.githubusercontent.com/79143800/161475437-d6a5dd50-c6b8-47d9-89d6-8c26d143cbd1.gif" width="300"/> |

|                                                         6.Delete                                                          |                                                      7.Detail                                                      |
| :----------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------: |
| <img src="https://user-images.githubusercontent.com/79143800/161475744-31525862-f77a-40de-bc45-b695f807b092.gif" width="300"/> | <img src="https://user-images.githubusercontent.com/79143800/161476002-9de14fc6-2b8b-44e0-8597-8dcf056a149d.gif" width="300"/> |
</div>

<br/>


# 🧐 프로젝트 특징

# AutoMic Design 패턴 그게 뭔데?

> 아토믹 디자인 패턴이란 ?

“ 디자인 요소들을 나누어 파악하고 이 요소들이 조합되는 과정을 통해서 디자인을 구성하는 방식 ”

<div>
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpZeYW%2FbtqBWssRQAW%2Fp5uMc3XeSIUYPk6PThaeek%2Fimg.png"/>
<div>

[출처: 아토믹디자인(Atomic Design) 방법론, 간단하게 이해하고 응용하기](https://uxdev.org/entry/%EC%95%84%ED%86%A0%EB%AF%B9%EB%94%94%EC%9E%90%EC%9D%B8-Atomic-Design-%EC%9B%90%EC%9E%90%EB%8B%A8%EC%9C%84%EB%94%94%EC%9E%90%EC%9D%B8-%EB%B0%A9%EB%B2%95%EB%A1%A0-%EA%B0%84%EB%8B%A8%ED%95%98%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B3%A0-%EC%9D%91%EC%9A%A9%ED%95%98%EA%B8%B0)

- `ATOM` 최소 디자인 요소들을 Atoms(원자들)로 파악한다
- `MOLECULES` Atoms들이 조합되어 MOLECULES(분자들)을 형성한다
- `ORGANISMS` MOLECULES(분자들)이 조합되어 보다 큰 의미 단위인 ORGANISMS(유기체)를 구성한다
- `TEMPLATES` ORGANISMS(유기체)이 모여 구성하는 실질적 디자인 화면이다.
- `PAGES` TEMPLATES(템플릿)들이 상황과 컨텐츠에 맞게 적용되면서 PAGES(페이지)를 구성한다.

<br>

# 난 왜 Automic Design 패턴을 왜 적용하려 하는가?

난 체계적인것을 좋아하고 정리하는 것을 좋아한다. 개발을 하는데 있어서 프로젝트에 체계화가 잡혀있다면 데이터의 흐름을 빠르게 이해할 수 있으며 개발자 스스로가 프로젝트에 대한 주도권을 가질 수 있게 된다. 그 중에서도 리액트의 컴포넌트 단위의 모듈과 함께 잘 갖추어진 디자인 시스템을 갖고 있다면 유지보수를 하기 편할 뿐 아니라 팀원들과 협업을 하는데 있어서도 유리하다. 또한 다른 사람에게 내가 가지고 있는 생각을 전달할 때 역시 잘 갖추어진 체계와 시스템이 있다면 분명 설득력있게 전달 될 것이다. 아토믹 디자인 패턴을 적용함으로써 나는 다른 나의 체계성을 다른사람에게 설득력 있게 전달하고싶다.

<br>

> Automic Design 패턴 적용 실패 경험

지난번 EarthMarket 리액트 프로젝트를 진행하면서 처음으로 아토믹 디자인 패턴을 알게되었고 AutomicDesign 패턴을 구성하려고 했다. 하지만 리액트의 상태 흐름에 대하여 제대로 이해하지 못했고 상태 관리를 어떻게 하는줄 몰랐다. 리액트의 생명주기, 가상돔의 역할, 재조정과정 등등을 고려한 개발을 전혀 하지 못했다. 그런 상태에서 그저 아토믹 디자인 패턴이 좋아보여 적용을 하려하였으니 당연히 구조를 제대로 잡지 못했다.. 하지만 이번에 리액트 강의를 제대로 들으며 상태관리에 대한 이해도가 높아졌기에, 실패의 경험을 이제 성공의 경험으로 만들고자 한다.

# 어떤식으로 AutomicDesign System을 적용했는가?

> Tree 구조

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161205328-ce0f661d-add0-4bc0-8a89-e1cc78c825ab.png" />
</div>
<br>

> 폴더 구조

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161205355-9775b7c2-aec2-4c63-bce0-bf523a592ec7.png" />
</div>

Component폴더 하위에 atom, molecule, organisms, template으로 구성했다

## 폴더구조 - Atom

> 최소 디자인 요소들로 구성

- `예제 코드`
  ```jsx
  const Button = ({ text, type, onClick }) => {
    const btnType = ["positive", "negative"].includes(type) ? type : "default";
    return (
      <StyledButton className={btnType} onClick={onClick}>
        {text}
      </StyledButton>
    );
  };
  export default Button;
  ```

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161205444-0e9bf615-7933-4c75-ad33-5f72b3591007.png" width="29%" />
<img src="https://user-images.githubusercontent.com/79143800/161205512-afaab0ad-da4f-46db-a056-eac363302ff0.png" width="50%"/>
</div>

<aside>
💡 Button 역할 이외에 그 어떤 역할도 하고 있지 않다. 이렇게 만들어진 Atom들은 molecule에 구성 요소로 역할을 하게 된다.

</aside>

## 폴더구조 - molecule

> Atoms들이 조합되어 MOLECULES(분자들)을 형성한다

- `예제 코드`
  ```jsx
  import CommonText from "../../atom/text/CommonText";
  const HomeInfoBox = ({ onClick, date, content }) => {
    return (
      <Wrapper onClick={onClick}>
        <CommonText descript={content} size={18} />
      </Wrapper>
    );
  };
  export default HomeInfoBox;
  ```

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161205571-bc98cc08-a377-4229-8b77-13253a5b2c79.png" width="29%" />
<img src="https://user-images.githubusercontent.com/79143800/161205611-3a5707cd-b8a3-4355-a509-d8ff400838c7.png" width="50%"/>
</div>

<aside>
💡 분자들은 Atoms의 조합으로 생기게 된다. Atom으로 생긴 요소들은 하나의 Wrapper 태그 아래 Atom요소를 덮는 요소로 사용이 된다. 이렇게 구성된 박스들은 주로 상위 컨테이너의 flex 속성으로 인한 정렬 대상이 된다
</aside>

## 폴더구조 - Organism

> MOLECULES(분자들)이 조합되어 보다 큰 의미 단위인 ORGANISMS(유기체)를 구성한다

- `예제코드`

  ```jsx
  import SubTitleBox from "../../molecule/common/SubTitleBox";
  import EditorEmotionList from "./EditorEmotionList";

  const EditorEmotionItem = () => {
    return (
      <section>
        <SubTitleBox />
        <EditorEmotionList />
      </section>
    );
  };
  export default EditorEmotionItem;
  ```

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161205697-0a965f50-69b4-4b69-9f0a-9f6fb155ffd9.png" width="29%" />
<img src="https://user-images.githubusercontent.com/79143800/161205737-f18f9fde-4575-4b42-9aec-736bcced4d49.png" width="50%"/>
</div>

- Organism은 Molecule들의 집합으로 이루어져있다. 성격에 따라서 List가 될 수 있고 Item이 될 수 있다. 예를들어 Organism의 성격을 띄고 있지만 Organism 요소 안에서 또 다른 Organism이 존재할 경우 List > Item 으로 구분짓는다.

> Organism in Organism

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161205795-04074bbb-3615-4c20-982e-a230fd76445a.png" width="29%" />
<img src="https://user-images.githubusercontent.com/79143800/161205812-9de2167c-78cb-4dee-b2dc-4d02b59f538a.png" width="50%"/>
</div>

예를들면 각 게시글 하나는 Organism Item의 성격을 가지고 있다. 3개의 분자가 모여 구성된 Case이기 때문이다. 하지만 이 게시물을 담고있는 Organism 역시 Organism의 구성요소로 볼 수 있다. 이 외에도 Edit 페이지의 EidtorEmotionItem과 List는 둘은 동시에 Organism 성격을 갖고있다. 이로써 두 가지 상황이 가능하다

1. List 성격을 가진 Organism이 Item 컴포넌트에 속하는 경우
2. Item 성격을 가진 Organism이 List 컴포넌트에 속하는 경우.

이런 상황에는 UI의 속성에 맞게 Organism > Organim으로 분류를 해주었다.

## 폴더구조 - Template

- `예시코드`

  ```jsx
  import HomeSelectItem from "../organisms/home/HomeSelecItem";
  import HomeMemoList from "../organisms/home/HomeMemoList";

  const HomeContainer = ({ MonthData }) => {
    const [sortType, setSortType] = useState("latest");
    const [filter, setFilter] = useState("all");
    return (
      <Article>
        <HomeSelectItem
          sortType={sortType}
          setSortType={setSortType}
          filter={filter}
          setFilter={setFilter}
        />
        <HomeMemoList
          filter={filter}
          sortType={sortType}
          MonthData={MonthData}
        />
      </Article>
    );
  };
  export default HomeContainer;
  // HomeSelectItem 컴포넌트와 HomeMemoList 컴포넌트는 동일한 상태값을 공유한다.
  ```

- `TEMPLATES` ORGANISMS(유기체)이 모여 구성하는 실질적 디자인 화면이다.

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161205842-6ac6d320-3715-48f1-879e-d086d6c0cbed.png" width="29%" />
<img src="https://user-images.githubusercontent.com/79143800/161205898-f4e77175-ab49-4d17-b0aa-0679eda4f7cb.png" width="50%"/>
</div>

Template은 Container라는 파일명으로 관리된다. Template은 Organism의 집합으로 이루어진 UI를 의미한다. 보통 Template은 두 Organism이 화면에 보여질 상태값을 공유할 때 묶여진다.

## 폴더구조 - Pages

> `PAGES` TEMPLATES(템플릿)들이 상황과 컨텐츠에 맞게 적용되면서 PAGES(페이지)를 구성한다.

```jsx
import CommonHeader from "../components/organisms/common/CommonHeader";
import HomeContainer from "../components/template/HomeContainer";

const Home = () => {
  return (
    <>
      <CommonHeader />
      <HomeContainer />
    </>
  );
};

export default Home;
```

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161205964-0d533f95-0b59-454f-9e4a-4c61c5228450.png" width="29%" />
<img src="https://user-images.githubusercontent.com/79143800/161205976-a4b3a125-dc87-4258-98b8-2efee6b2d24a.png" width="50%"/>
</div>

- 마지막으로 화면에 보여질 Template과 Organism의 레이아웃을 합하여 화면에 실제로 보여질 요소들로 구성을 시킨다. 이로써 페이지의 화면을 구성한다. 이때 template으로 묶어진 요소들의 특징은 서로가 상태값을 공유한다는 것이다.

# 마치며

구조를 잡다보니깐 계속해서 마음에 안드는 부분이 존재했고 상태관리와 컴포넌트의 레이아웃을 함께 고려하여 컴포넌트를 구조분해 하는일이 쉽지 않음을 느꼈다. 리액트의 특성상 컴포넌트의 상태가 변화면 리-렌더링이 일어나기 때문에 한 구조로 묶어버리더라도 결국에 컨테이너로 묶어버린 컴포넌트들이 리-렌더링 상태애 계속되서 노출이 된다면 이는 성능 최적화에 실패하는 경우가 되어버리기 때문이다.

<div align='center' >
<img src="https://user-images.githubusercontent.com/79143800/161206019-18d4568b-2f14-4883-89db-f01c99008af2.png" />
</div>

EditorCotainer 같은 경우에는 상태를 입력함에 따라 상태값이 변화가 되는 경우가 많았다. 예를들면 위 Item요소들을 한 군데로 묶어버리고 Props로 상태 변경을 하는 상태변경 함수를 전달하여 레이아웃을 좀 더 명확하게 분리를 하는 방법도 있지만 그렇게 할 경우 Item 요소중 하나의 값만 변경이 되어버려도 컴포넌트 전체가 리-렌더링 되는 문제가 발생하게 된다. 그래서 Page의 구조를 살리지 못하고 일단은 EditorContainer에 모든 Organism을 구성했다.

Header Organism 컴포넌트라도 분리해서 State 끌어올리기를 통해서 분리를 해주려고 했으나 오히려 더 복잡한 버그가 발생해서 해결하지 못했다. 이 부분에 대해서는 추후과제로 조금 더 공부해 봐야 할 것 같다.

## 결론

결국에는 이런 디자인 시스템을 적용하기 위해서는 디자이너와 정말 많은 커뮤니케이션이 일어나야 할 것 같다는 생각이 들었다. 디자이너가 오로지 디자인의 관점으로만 레이아웃을 만들고 개발자가 UI를 만들어야 하는 상황이 온다면 개발자는 디자이너가 의도한대로 컴포넌트를 재 설계해야한다. 이 과정에서 최적화와 상태관리를 위하여 프로젝트 구조의 흐름을 깨뜨리는 상황이 발생할 수 있을 것 같다고 생각했다.
<br>

# 2. Redux Ducks Patten

> What is Redux Ducks Patten

기존에 EarthMarket 프로젝트를 진행하면서 Action Type(액션 타입), Action Creator(액션 생성 함수), Reducer(리듀서)를 모두 하나의 파일로 관리하지 않고 따로따로 역할을 분리해서 사용했다. 기존 어스마켓의 프로젝트 규모가 큰 편이었기에 파일별로 역할을 나누었었다. 하지만 Redux Ducks패턴은 기존에 리덕스 모듈들을 파일별로 나누어 작성하는 것이 아닌 하나의 파일에 두어서 함께 관리하는 것이다

```jsx
// Constant

const MEMORY_INIT = "MEMORY_INIT";
const MEMORY_CREATE = "MEMORY_CREATE";
const MEMORY_REMOVE = "MEMORY_REMOVE";
const MEMORY_UPDATE = "MEMORY_UPDATE";

// Action

export const initalData = (data) => ({
...
});

export const onCreate = (date, content, emotion) => ({
...
});

export const onRemove = (targetId) => ({
...
});

export const onEdit = (targetId, date, content, emotion) => ({
...
});

// Reducer

const memoryReducer = (state = {}, action) => {
  let newState = [];
  switch (action.type) {
    case MEMORY_INIT: {
...
    }
    case MEMORY_CREATE: {
...
    }
    case MEMORY_REMOVE: {
...
    }
    case MEMORY_UPDATE: {
...
    }
    default:
      return state;
  }
...
  return newState;
};

export default memoryReducer;
```

Ducks 패턴 같은 경우에는 module이라는 폴더에서 Ducks 패턴으로 만들어진 파일을 관리한다. 그리고 store 로직을 index.js를 통해서 관리를 해주는데 나는 방식을 좀 다르게했다. 데이터가 실질적으로 관리가 되는 reducer함수는 store함수에서 관리되는게 좀 더 구분짓기 편하다고 여겨 index.js가 아닌 store.js파일을 만들어서 관리해주었다.

- Store.js

```jsx
import { combineReducers } from "redux";
import { createStore } from "redux";
import memoryReducer from "./module/memoryReducer";
import { composeWithDevTools } from "redux-devtools-extension";

const reducer = combineReducers({
  memoryReducer,
});

const store = createStore(reducer, composeWithDevTools());

export default store;
```

<br>

# 📲 프로젝트 실행 방법

🖥 코드 실행

```
  npm install
  npm start
```

<br/>

# 📁 프로젝트 구조

```
📦src
 ┣ 📂components
 ┃ ┣ 📂atom
 ┃ ┃ ┣ 📂etc
 ┃ ┃ ┣ 📂icon
 ┃ ┃ ┣ 📂img
 ┃ ┃ ┣ 📂logo
 ┃ ┃ ┗ 📂text
 ┃ ┣ 📂molecule
 ┃ ┃ ┣ 📂common
 ┃ ┃ ┣ 📂detail
 ┃ ┃ ┣ 📂editor
 ┃ ┃ ┗ 📂home
 ┃ ┣ 📂organisms
 ┃ ┃ ┣ 📂common
 ┃ ┃ ┣ 📂detail
 ┃ ┃ ┣ 📂editor
 ┃ ┃ ┗ 📂home
 ┃ ┗ 📂template
 ┣ 📂module
 ┣ 📂pages
 ┣ 📂styles
 ┣ 📂util
 ┣ 📜App.js
 ┣ 📜index.js
 ┗ 📜store.js
```

<br/>

# 💡 라이브러리
```
    "lodash": "^4.17.21",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-redux": "^7.2.6",
    "react-router-dom": "^6.2.2",
    "react-scripts": "5.0.0",
    "redux": "^4.1.2",
    "redux-devtools-extension": "^2.13.9",
    "styled-components": "^5.3.3",
    "styled-reset": "^4.3.4",
```
